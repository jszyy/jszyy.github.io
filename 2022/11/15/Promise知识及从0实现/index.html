<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Promise介绍Promise起源与用途Promise最早在社区提出和实现，在ES6写入了语言标准。  tip: ES6即ECMA-262第六版，这一版包含了这个规范有史以来最重要的一批增强特性，Javascript是ECMA-262规范的实现   Promise是异步编程的解决方案，比传统的回调函数解决方式更加合理更加强大更加优雅。 语法上： 使用Promise构造函数对异步操作进行封装以生成">
<meta property="og:type" content="article">
<meta property="og:title" content="Promise知识及从0实现">
<meta property="og:url" content="http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="玉印说">
<meta property="og:description" content="Promise介绍Promise起源与用途Promise最早在社区提出和实现，在ES6写入了语言标准。  tip: ES6即ECMA-262第六版，这一版包含了这个规范有史以来最重要的一批增强特性，Javascript是ECMA-262规范的实现   Promise是异步编程的解决方案，比传统的回调函数解决方式更加合理更加强大更加优雅。 语法上： 使用Promise构造函数对异步操作进行封装以生成">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-14T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-22T06:11:56.761Z">
<meta property="article:author" content="玉印">
<meta property="article:tag" content="#">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Promise知识及从0实现</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/feeling/">瞎说</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2022/11/15/React%20Hook%20%E5%AE%9E%E7%8E%B0%E9%80%9A%E7%94%A8%E9%80%89%E6%8B%A9%E6%90%9C%E7%B4%A2%E7%BB%84%E4%BB%B6/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/11/15/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&text=Promise知识及从0实现"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&title=Promise知识及从0实现"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&is_video=false&description=Promise知识及从0实现"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Promise知识及从0实现&body=Check out this article: http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&title=Promise知识及从0实现"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&title=Promise知识及从0实现"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&title=Promise知识及从0实现"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&title=Promise知识及从0实现"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&name=Promise知识及从0实现&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&t=Promise知识及从0实现"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">Promise介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E8%B5%B7%E6%BA%90%E4%B8%8E%E7%94%A8%E9%80%94"><span class="toc-number">1.1.</span> <span class="toc-text">Promise起源与用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">常见的异步编程场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Promise"><span class="toc-number">1.3.</span> <span class="toc-text">为什么使用Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">什么是回调地狱？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.3.2.</span> <span class="toc-text">回调地狱的缺点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise%E7%89%B9%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">Promise特点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">Promise的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">Promise的缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">Promise使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">3.1.</span> <span class="toc-text">Promise实例创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-prototype-then"><span class="toc-number">3.2.</span> <span class="toc-text">Promise.prototype.then</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-prototype-catch"><span class="toc-number">3.3.</span> <span class="toc-text">Promise.prototype.catch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-resolve"><span class="toc-number">3.4.</span> <span class="toc-text">Promise.resolve</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-reject"><span class="toc-number">3.5.</span> <span class="toc-text">Promise.reject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-all"><span class="toc-number">3.6.</span> <span class="toc-text">Promise.all</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-race"><span class="toc-number">3.7.</span> <span class="toc-text">Promise.race</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">3.8.</span> <span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98Promise%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.8.1.</span> <span class="toc-text">如何改变Promise对象的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise-then-%E7%9A%84%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-number">3.8.2.</span> <span class="toc-text">promise.then() 的返回结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">3.9.</span> <span class="toc-text">promise为什么可以链式调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E7%9A%84%E5%BC%82%E5%B8%B8%E7%A9%BF%E9%80%8F"><span class="toc-number">3.10.</span> <span class="toc-text">promise的异常穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%ADpromise%E9%93%BE"><span class="toc-number">3.10.1.</span> <span class="toc-text">中断promise链</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99Promise"><span class="toc-number">4.</span> <span class="toc-text">手写Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.</span> <span class="toc-text">构造函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#then%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">then方法的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#catch%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">catch方法的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-resolve%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.</span> <span class="toc-text">Promise.resolve方法实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-reject%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.5.</span> <span class="toc-text">Promise.reject方法实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-race%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.6.</span> <span class="toc-text">Promise.race方法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E4%BB%A5%E5%8F%8A%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86"><span class="toc-number">4.6.1.</span> <span class="toc-text">完整代码以及细节处理</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Promise知识及从0实现
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">张玉印</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-11-14T16:00:00.000Z" class="dt-published" itemprop="datePublished">2022-11-15</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Posts/">Posts</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/" rel="tag">#</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="Promise介绍"><a href="#Promise介绍" class="headerlink" title="Promise介绍"></a>Promise介绍</h1><h2 id="Promise起源与用途"><a href="#Promise起源与用途" class="headerlink" title="Promise起源与用途"></a>Promise起源与用途</h2><p>Promise最早在社区提出和实现，在ES6写入了语言标准。</p>
<blockquote>
<p>tip: ES6即ECMA-262第六版，这一版包含了这个规范有史以来最重要的一批增强特性，Javascript是ECMA-262规范的实现</p>
</blockquote>
<ul>
<li>Promise是异步编程的解决方案，比传统的回调函数解决方式更加合理更加强大更加优雅。</li>
<li>语法上： 使用Promise构造函数对异步操作进行封装以生成Promise实例</li>
<li>功能上： promise对象用来封装一个异步操作并提供统一的API，使得各种异步操作都可以用同样的方式进行处理</li>
</ul>
<h2 id="常见的异步编程场景"><a href="#常见的异步编程场景" class="headerlink" title="常见的异步编程场景"></a>常见的异步编程场景</h2><ul>
<li><p>fs文件操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require(&#x27;fs&#x27;).readFile(&#x27;./index.html&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">    // 回调函数</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ajax操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.get(&#x27;/api/getUser&#x27;,(data)=&gt;&#123;</span><br><span class="line">    //handleData();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timeout&#x27;);</span><br><span class="line">&#125;,1000);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="为什么使用Promise"><a href="#为什么使用Promise" class="headerlink" title="为什么使用Promise"></a>为什么使用Promise</h2><ul>
<li>支持链式调用，将异步操作以同步操作的流程表达出来，可以解决回调地狱问题</li>
</ul>
<h3 id="什么是回调地狱？"><a href="#什么是回调地狱？" class="headerlink" title="什么是回调地狱？"></a>什么是回调地狱？</h3><p>回调函数嵌套调用，外部回调函数异步执行结果是嵌套的回调的执行条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 回调地狱典型场景</span><br><span class="line">asyncFunc1(opt,(...args1) =&gt; &#123;</span><br><span class="line">    asyncFunc2(opt,(...args2) =&gt; &#123;</span><br><span class="line">        asyncFunc3(opt,(...args3) =&gt; &#123;</span><br><span class="line">            asyncFunc4(opt,(...args4) =&gt; &#123;</span><br><span class="line">                //TODO: some opt</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="回调地狱的缺点："><a href="#回调地狱的缺点：" class="headerlink" title="回调地狱的缺点："></a>回调地狱的缺点：</h3><p>不便于阅读，不便于异常处理，不利于身心愉快</p>
<ul>
<li>指定回调函数的方式更加灵活</li>
</ul>
<p><b>传统方式：</b>  必须在启动异步任务之前指定<br><b>Promise：</b>  可以随时监听异步任务的状态，随时指定回调函数，一个或者多个。</p>
<ul>
<li>Promise提供统一的api，使得控制异步操作更加容易。</li>
</ul>
<p>提供了哪些api在后续的使用中会详细阐述</p>
<h1 id="Promise特点"><a href="#Promise特点" class="headerlink" title="Promise特点"></a>Promise特点</h1><h2 id="Promise的特性"><a href="#Promise的特性" class="headerlink" title="Promise的特性"></a>Promise的特性</h2><ul>
<li>对象状态不受外界影响</li>
</ul>
<p>Promise对象代表一个异步操作，有三种状态：pending进行中，fulfilled成功，rejected失败<br>只有异步操作结束才能改变状态，其他任何操作都不能改变。状态存储在Promise对象的[[PromiseState]]属性中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Promise的两个属性：</span><br><span class="line">let promiseA = new Promise((resolve,reject)=&gt;&#123;resolve();&#125;)</span><br><span class="line">// 状态对应promiseA的[[PromiseState]]字段。</span><br><span class="line">let promiseB = new Promise((resolve,reject)=&gt;&#123;resolve(1111);&#125;)</span><br><span class="line">// [[PromiseResult]]的值为 1111，这个字段用于存储 resolve(val)或者reject(val)的参数[val]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: Promise本意是承诺，也是因为此原因，想一想这是多么浪漫的名字。</p>
</blockquote>
<ul>
<li>一旦状态改变，就不会再发生变化</li>
</ul>
<p>Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<h2 id="Promise的缺点"><a href="#Promise的缺点" class="headerlink" title="Promise的缺点"></a>Promise的缺点</h2><ul>
<li>一旦新建，立即执行，无法中途取消</li>
<li>Promise内部抛出的错误，无法反映到外部</li>
<li>pending状态时无法知道进展到哪一个阶段</li>
</ul>
<h1 id="Promise使用"><a href="#Promise使用" class="headerlink" title="Promise使用"></a>Promise使用</h1><h2 id="Promise实例创建"><a href="#Promise实例创建" class="headerlink" title="Promise实例创建"></a>Promise实例创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<ul>
<li>resolve函数：将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li>
<li>reject函数：将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>
</ul>
<h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h2><p>Promise实例生成以后，可以用then方法分别指定fulfilled状态和rejected状态的回调函数<br>最终会返回一个新的Promise对象</p>
<blockquote>
<p>tip: then中的回调函数是可选的，不一定要提供</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // fulfilled状态的处理</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // rejected状态的处理</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h2><p>catch用于处理状态为rejected的回调函数<br>最终会返回一个新的Promise对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.catch((err)=&gt;&#123;</span><br><span class="line">    handleReject();</span><br><span class="line">    //</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h2><p>返回成功或者失败的Promise对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let promiseA = Promise.resolve(1);</span><br><span class="line">// 如果传入的参数为非Promise类型的对象，则返回的结果为成功的Promise对象</span><br><span class="line">let PromiseB = Promise.resolve(new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    reject(&#x27;err&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">// 如果传入的参数为Promise对象，则参数Promise返回的结果就是 Promise.resolve返回的结果</span><br><span class="line">// 比如这时return 一个[[PromiseResult]]的值为err的Promise对象</span><br></pre></td></tr></table></figure>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h2><p>返回一个失败的Promise对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let PromiseA = Promise.reject(new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(&#x27;err&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">// 无论传入是啥，就返回一个失败的Promise对象，[[PromiseResult]]的值为 Promise.reject的参数</span><br></pre></td></tr></table></figure>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>接收的参数是由n个Promise对象的数组。</p>
<blockquote>
<p>tips: 返回结果是新的promise，只有所有的Promise对象都成功才成功，只要有一个失败了就直接失败</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let promise1 = Promise.resolve(1);</span><br><span class="line">let promise2 = Promise.resolve(2);</span><br><span class="line">let promise3 = Promise.reject(3);</span><br><span class="line">const res = Promise.all([promise1,promise2,promise3]);</span><br><span class="line">//此时输出为 [[PromiseState]]是rejected，[[PromiseResult]]是3的Promise</span><br><span class="line">const res = Promise.all([promise1,promise2]);</span><br><span class="line">//此时输出为 [[PromiseState]]是fulfilled，[[PromiseResult]]是[1,2]的Promise</span><br></pre></td></tr></table></figure>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><p>接收的参数是由n个Promise对象的数组。</p>
<blockquote>
<p>tips: 返回结果是新的promise，第一个完成的promise的结果状态就是最终结果的状态。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let promise1 = Promise.resolve(1);</span><br><span class="line">let promise2 = Promise.resolve(2);</span><br><span class="line">let promise3 = Promise.reject(3);</span><br><span class="line">const res = Promise.race([promise1,promise2,promise3]);</span><br><span class="line">//此时输出为 [[PromiseState]]是fulfilled，[[PromiseResult]]是1的Promise</span><br></pre></td></tr></table></figure>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="如何改变Promise对象的状态"><a href="#如何改变Promise对象的状态" class="headerlink" title="如何改变Promise对象的状态"></a>如何改变Promise对象的状态</h3><ul>
<li>resolve()  &#x2F;&#x2F; pending &#x3D;&gt; fulfilled</li>
<li>reject()   &#x2F;&#x2F; pending &#x3D;&gt; rejected</li>
<li>抛出错误 throw ‘err’ &#x2F;&#x2F; pending &#x3D;&gt; rejected</li>
</ul>
<h3 id="promise-then-的返回结果"><a href="#promise-then-的返回结果" class="headerlink" title="promise.then() 的返回结果"></a>promise.then() 的返回结果</h3><ul>
<li>如果抛出异常，则返回rejected的Promise对象</li>
<li>如果返回的是非promise类型的任意值，则返回状态为resolved的Promise对象</li>
<li>如果返回的是一个新的promise，则该promise的结果会成为新的promise结果</li>
</ul>
<h2 id="promise为什么可以链式调用"><a href="#promise为什么可以链式调用" class="headerlink" title="promise为什么可以链式调用"></a>promise为什么可以链式调用</h2><p>因为then,catch,all,race等等所有的promise的api的返回值是新的promise对象。<br>所以可以继续打点调用promise的方法，以此种方式将任务串联起来</p>
<h2 id="promise的异常穿透"><a href="#promise的异常穿透" class="headerlink" title="promise的异常穿透"></a>promise的异常穿透</h2><ul>
<li>当使用promise的then进行链式调用时，可以在最后指定失败的回调</li>
<li>前面的任何错误都会在最后传到失败的回调中去处理<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let p1 = Promise.resolve(1);</span><br><span class="line">p1.then((value)=&gt;&#123;</span><br><span class="line">    console.log(11);</span><br><span class="line">&#125;).then((value)=&gt;&#123;</span><br><span class="line">    throw &#x27;err&#x27;;</span><br><span class="line">&#125;).then((value)=&gt;&#123;</span><br><span class="line">    console.log(22);</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">//输出： 11  err</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="中断promise链"><a href="#中断promise链" class="headerlink" title="中断promise链"></a>中断promise链</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let p1 = Promise.resolve(1);</span><br><span class="line">p1.then((value)=&gt;&#123;</span><br><span class="line">    console.log(11);</span><br><span class="line">&#125;).then((value)=&gt;&#123;</span><br><span class="line">    console.log(22);</span><br><span class="line">&#125;).then((value)=&gt;&#123;</span><br><span class="line">    console.log(33);</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">//输出：11 22 33</span><br></pre></td></tr></table></figure>
<p>那我们怎么去中断这个回调函数的联调呢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let p1 = Promise.resolve(1);</span><br><span class="line">p1.then((value)=&gt;&#123;</span><br><span class="line">    console.log(11);</span><br><span class="line">&#125;).then((value)=&gt;&#123;</span><br><span class="line">    console.log(22);</span><br><span class="line">    return new Promise(()=&gt;&#123;&#125;);</span><br><span class="line">&#125;).then((value)=&gt;&#123;</span><br><span class="line">    console.log(33);</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">//输出：11 22</span><br></pre></td></tr></table></figure>
<p>答案就是返回一个状态为pending的promise对象</p>
<h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><p>代码逐步迭代，可以对照着看，我把注释都写得比较清晰了~</p>
<h2 id="构造函数实现"><a href="#构造函数实现" class="headerlink" title="构造函数实现"></a>构造函数实现</h2><p>我们第一步首先就是完成Promise的构造函数，构造函数我们简单去想，其实就是接收一个执行器函数，执行器函数有两个参数，这个方法阔以改变Promise对象的状态和结果。ok，说干就干！</p>
<blockquote>
<p>tips:</p>
<p>注意！throw err也可以修改Promise的状态与结果!<br>promise的状态只能修改一次，需要做限制</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 万里长城第一步</span><br><span class="line">function Promise(executor)&#123;</span><br><span class="line">    this.promiseState = &#x27;pending&#x27;;</span><br><span class="line">    this.promiseResult = null;</span><br><span class="line">    const resolve = val =&gt; &#123;</span><br><span class="line">        // 状态只能修改一次</span><br><span class="line">        if(this.promiseState !== &#x27;pending&#x27;) return;</span><br><span class="line">        // 1. 要去修改Promise对象的状态([[promiseState]]),置为成功fulfilled</span><br><span class="line">        this.promiseState = &#x27;fulfilled&#x27;;</span><br><span class="line">        // 2. 要去修改Promise对象的状态([[promiseResult]])</span><br><span class="line">        this.promiseResult = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const reject = err =&gt; &#123;</span><br><span class="line">        // 状态只能修改一次</span><br><span class="line">        if(this.promiseState !== &#x27;pending&#x27;) return;</span><br><span class="line">        // 1. 要去修改Promise对象的状态([[promiseState]]),置为失败rejected</span><br><span class="line">        this.promiseState = &#x27;rejected&#x27;;</span><br><span class="line">        // 2. 要去修改Promise对象的状态([[promiseResult]])</span><br><span class="line">        this.promiseResult = err;</span><br><span class="line">    &#125;</span><br><span class="line">    // 为什么要加try catch 是因为，throw err也相当于调用reject了【前面说过没看过的去补课】</span><br><span class="line">    try&#123;</span><br><span class="line">        /*</span><br><span class="line">        * 同步执行执行器函数</span><br><span class="line">        * 执行器函数接收两个参数，一个是resolve，一个是reject</span><br><span class="line">        */</span><br><span class="line">        executor(resolve,reject);</span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="then方法的实现"><a href="#then方法的实现" class="headerlink" title="then方法的实现"></a>then方法的实现</h2><p>首先按照之前说过的，then支持两个参数，分别是成功和失败的回调，而且这两个参数可传可不传。<br>其次，因为异步任务的问题，并且支持多个回调，所以我们需要对回调函数采用数组进行存储，所以引入了新的变量，callbackList<br>而且我们需要注意then的返回结果也是Promise对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">// 万里长城今犹在~</span><br><span class="line">function Promise(executor)&#123;</span><br><span class="line">    //保存promise状态</span><br><span class="line">    this.promiseState = &#x27;pending&#x27;;</span><br><span class="line">    //保存promise结果</span><br><span class="line">    this.promiseResult = null;</span><br><span class="line">    //用于保存异步回调函数列表</span><br><span class="line">    this.callbackList = [];</span><br><span class="line">    const resolve = val =&gt; &#123;</span><br><span class="line">        // 状态只能修改一次</span><br><span class="line">        if(this.promiseState !== &#x27;pending&#x27;) return;</span><br><span class="line">        // 1. 要去修改Promise对象的状态([[promiseState]]),置为成功fulfilled</span><br><span class="line">        this.promiseState = &#x27;fulfilled&#x27;;</span><br><span class="line">        // 2. 要去修改Promise对象的状态([[promiseResult]])</span><br><span class="line">        this.promiseResult = val;</span><br><span class="line">        // 调用成功的回调【callbackList存起来的】</span><br><span class="line">        for(let callback of this.callbackList)&#123;</span><br><span class="line">            callback.onResolved(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const reject = err =&gt; &#123;</span><br><span class="line">        // 状态只能修改一次</span><br><span class="line">        if(this.promiseState !== &#x27;pending&#x27;) return;</span><br><span class="line">        // 1. 要去修改Promise对象的状态([[promiseState]]),置为失败rejected</span><br><span class="line">        this.promiseState = &#x27;rejected&#x27;;</span><br><span class="line">        // 2. 要去修改Promise对象的状态([[promiseResult]])</span><br><span class="line">        this.promiseResult = err;</span><br><span class="line">        // 调用失败的回调【callbackList存起来的】</span><br><span class="line">        for(let callback of this.callbackList)&#123;</span><br><span class="line">            callback.onRejected(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 为什么要加try catch 是因为，throw err也相当于调用reject了【前面说过没看过的去补课】</span><br><span class="line">    try&#123;</span><br><span class="line">        /*</span><br><span class="line">        * 同步执行执行器函数</span><br><span class="line">        * 执行器函数接收两个参数，一个是resolve，一个是reject</span><br><span class="line">        */</span><br><span class="line">        executor(resolve,reject);</span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//then方法</span><br><span class="line">Promise.prototype.then = function(onResolved,onRejected)&#123;</span><br><span class="line">    const self = this;</span><br><span class="line"></span><br><span class="line">    // then方法会返回Promise</span><br><span class="line">    return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">        // 对返回值的处理进行封装</span><br><span class="line">        const handleCallback = (callback) =&gt; &#123;</span><br><span class="line">            // 如果回调函数中抛出错误，则reject</span><br><span class="line">            try&#123;</span><br><span class="line">                // 需要依据回调的返回结果确定then方法的返回值</span><br><span class="line">                // 现在的this会指向return的promise对象，所以使用self</span><br><span class="line">                const res = callback(self.promiseResult);</span><br><span class="line">                if(res instanceof Promise)&#123;</span><br><span class="line">                    //如果回调返回结果是个Promise</span><br><span class="line">                    res.then(val =&gt; &#123;</span><br><span class="line">                        resolve(val);</span><br><span class="line">                    &#125;,err =&gt; &#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    // 返回结果不是Promise</span><br><span class="line">                    resolve(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch(err)&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //调用回调函数</span><br><span class="line">        if(this.promiseState === &#x27;fulfilled&#x27;)&#123;</span><br><span class="line">            handleCallback(onResolved);</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.promiseState === &#x27;rejected&#x27;)&#123;</span><br><span class="line">            handleCallback(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">        * 如果是pending状态，则异步任务，在改变状态的时候去调用回调函数</span><br><span class="line">        * 所以要保存回调函数</span><br><span class="line">        * 因为promise实例阔以指定多个回调，于是采用数组 </span><br><span class="line">        */</span><br><span class="line">        if(this.promiseState === &#x27;pending&#x27;)&#123;</span><br><span class="line">            this.callbackList.push(&#123;</span><br><span class="line">                onResolved:() =&gt; &#123;</span><br><span class="line">                    handleCallback(onResolved); </span><br><span class="line">                &#125;,</span><br><span class="line">                onRejected:() =&gt; &#123;</span><br><span class="line">                    handleCallback(onRejected);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="catch方法的实现"><a href="#catch方法的实现" class="headerlink" title="catch方法的实现"></a>catch方法的实现</h2><p>我们采用then方法去实现catch方法，但是catch可以处理异常穿透</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor)&#123;</span><br><span class="line">    //保存promise状态</span><br><span class="line">    this.promiseState = &#x27;pending&#x27;;</span><br><span class="line">    //保存promise结果</span><br><span class="line">    this.promiseResult = null;</span><br><span class="line">    //用于保存异步回调函数列表</span><br><span class="line">    this.callbackList = [];</span><br><span class="line">    const resolve = val =&gt; &#123;</span><br><span class="line">        // 状态只能修改一次</span><br><span class="line">        if(this.promiseState !== &#x27;pending&#x27;) return;</span><br><span class="line">        // 1. 要去修改Promise对象的状态([[promiseState]]),置为成功fulfilled</span><br><span class="line">        this.promiseState = &#x27;fulfilled&#x27;;</span><br><span class="line">        // 2. 要去修改Promise对象的状态([[promiseResult]])</span><br><span class="line">        this.promiseResult = val;</span><br><span class="line">        // 调用成功的回调【callbackList存起来的】</span><br><span class="line">        for(let callback of this.callbackList)&#123;</span><br><span class="line">            callback.onResolved(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const reject = err =&gt; &#123;</span><br><span class="line">        // 状态只能修改一次</span><br><span class="line">        if(this.promiseState !== &#x27;pending&#x27;) return;</span><br><span class="line">        // 1. 要去修改Promise对象的状态([[promiseState]]),置为失败rejected</span><br><span class="line">        this.promiseState = &#x27;rejected&#x27;;</span><br><span class="line">        // 2. 要去修改Promise对象的状态([[promiseResult]])</span><br><span class="line">        this.promiseResult = err;</span><br><span class="line">        // 调用失败的回调【callbackList存起来的】</span><br><span class="line">        for(let callback of this.callbackList)&#123;</span><br><span class="line">            callback.onRejected(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 为什么要加try catch 是因为，throw err也相当于调用reject了【前面说过没看过的去补课】</span><br><span class="line">    try&#123;</span><br><span class="line">        /*</span><br><span class="line">        * 同步执行执行器函数</span><br><span class="line">        * 执行器函数接收两个参数，一个是resolve，一个是reject</span><br><span class="line">        */</span><br><span class="line">        executor(resolve,reject);</span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//then方法</span><br><span class="line">Promise.prototype.then = function(onResolved,onRejected)&#123;</span><br><span class="line">    const self = this;</span><br><span class="line">    //处理异常穿透 并且为onResolved，onRejected设置默认值。因为这两个参数可以都不传</span><br><span class="line">    if(typeof onRejected !== &#x27;function&#x27;)&#123;</span><br><span class="line">        onRejected = err =&gt; &#123;</span><br><span class="line">            throw err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(typeof onResolved !== &#x27;function&#x27;)&#123;</span><br><span class="line">        onResolved = val =&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    // then方法会返回Promise</span><br><span class="line">    return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">        // 对返回值的处理进行封装</span><br><span class="line">        const handleCallback = (callback) =&gt; &#123;</span><br><span class="line">            // 如果回调函数中抛出错误，则reject</span><br><span class="line">            try&#123;</span><br><span class="line">                // 需要依据回调的返回结果确定then方法的返回值</span><br><span class="line">                // 现在的this会指向return的promise对象，所以使用self</span><br><span class="line">                const res = callback(self.promiseResult);</span><br><span class="line">                if(res instanceof Promise)&#123;</span><br><span class="line">                    //如果回调返回结果是个Promise</span><br><span class="line">                    res.then(val =&gt; &#123;</span><br><span class="line">                        resolve(val);</span><br><span class="line">                    &#125;,err =&gt; &#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    // 返回结果不是Promise</span><br><span class="line">                    resolve(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch(err)&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //调用回调函数</span><br><span class="line">        if(this.promiseState === &#x27;fulfilled&#x27;)&#123;</span><br><span class="line">            handleCallback(onResolved);</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.promiseState === &#x27;rejected&#x27;)&#123;</span><br><span class="line">            handleCallback(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">        * 如果是pending状态，则异步任务，在改变状态的时候去调用回调函数</span><br><span class="line">        * 所以要保存回调函数</span><br><span class="line">        * 因为promise实例阔以指定多个回调，于是采用数组 </span><br><span class="line">        */</span><br><span class="line">        if(this.promiseState === &#x27;pending&#x27;)&#123;</span><br><span class="line">            this.callbackList.push(&#123;</span><br><span class="line">                onResolved:() =&gt; &#123;</span><br><span class="line">                    handleCallback(onResolved); </span><br><span class="line">                &#125;,</span><br><span class="line">                onRejected:() =&gt; &#123;</span><br><span class="line">                    handleCallback(onRejected);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//catch方法</span><br><span class="line">Promise.prototype.catch = function(onRejected) &#123;</span><br><span class="line">    //  我们可以直接使用then方法实现</span><br><span class="line">    return this.then(undefined,onRejected);</span><br></pre></td></tr></table></figure>
<h2 id="Promise-resolve方法实现"><a href="#Promise-resolve方法实现" class="headerlink" title="Promise.resolve方法实现"></a>Promise.resolve方法实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//resolve方法</span><br><span class="line">Promise.resolve = function(val) &#123;</span><br><span class="line">    //返回值的情况在前文说过，可以在 Promise的使用一章找到</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        if(val instanceof Promise)&#123;</span><br><span class="line">            val.then(val =&gt; &#123;</span><br><span class="line">                resolve(val);</span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Promise-reject方法实现"><a href="#Promise-reject方法实现" class="headerlink" title="Promise.reject方法实现"></a>Promise.reject方法实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> //reject方法</span><br><span class="line">Promise.reject = function(err) &#123;</span><br><span class="line">    //返回值的情况在前文说过，可以在 Promise的使用一章找到</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        reject(err);</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line">Promise.all方法实现</span><br><span class="line">比较简单，回顾之前Promise.all的用法以及返回值，就阔以看懂~</span><br><span class="line">//可以先去回顾一下all方法的用法</span><br><span class="line">//all</span><br><span class="line">Promise.all = function(promiseList) &#123;</span><br><span class="line">    let count = 0;</span><br><span class="line">    let res = [];</span><br><span class="line">    const length = promiseList.length;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        for(let i = 0;i &lt; length; i++)&#123;</span><br><span class="line">            promiseList[i].then(val =&gt; &#123;</span><br><span class="line">                count++;</span><br><span class="line">                res[i] = val;</span><br><span class="line">                if(count === length)&#123;</span><br><span class="line">                    resolve(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,err =&gt; &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Promise-race方法实现"><a href="#Promise-race方法实现" class="headerlink" title="Promise.race方法实现"></a>Promise.race方法实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//race</span><br><span class="line">//要结束了！</span><br><span class="line">Promise.race = function(promiseList) &#123;</span><br><span class="line">    const length = promiseList.length;</span><br><span class="line">    //谁先完成谁就决定结果！</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        for(let i = 0;i &lt; length; i++)&#123;</span><br><span class="line">            promiseList[i].then(val =&gt; &#123;</span><br><span class="line">                resolve(val);</span><br><span class="line">            &#125;,err =&gt; &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整代码以及细节处理"><a href="#完整代码以及细节处理" class="headerlink" title="完整代码以及细节处理"></a>完整代码以及细节处理</h3><blockquote>
<p>tips: 细节回调函数是异步的 我们使用setTimeout进行包裹</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor)&#123;</span><br><span class="line">    //保存promise状态</span><br><span class="line">    this.promiseState = &#x27;pending&#x27;;</span><br><span class="line">    //保存promise结果</span><br><span class="line">    this.promiseResult = null;</span><br><span class="line">    //用于保存异步回调函数列表</span><br><span class="line">    this.callbackList = [];</span><br><span class="line">    const resolve = val =&gt; &#123;</span><br><span class="line">        // 状态只能修改一次</span><br><span class="line">        if(this.promiseState !== &#x27;pending&#x27;) return;</span><br><span class="line">        // 1. 要去修改Promise对象的状态([[promiseState]]),置为成功fulfilled</span><br><span class="line">        this.promiseState = &#x27;fulfilled&#x27;;</span><br><span class="line">        // 2. 要去修改Promise对象的状态([[promiseResult]])</span><br><span class="line">        this.promiseResult = val;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            // 调用成功的回调【callbackList存起来的】</span><br><span class="line">            for(let callback of this.callbackList)&#123;</span><br><span class="line">                callback.onResolved(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const reject = err =&gt; &#123;</span><br><span class="line">        // 状态只能修改一次</span><br><span class="line">        if(this.promiseState !== &#x27;pending&#x27;) return;</span><br><span class="line">        // 1. 要去修改Promise对象的状态([[promiseState]]),置为失败rejected</span><br><span class="line">        this.promiseState = &#x27;rejected&#x27;;</span><br><span class="line">        // 2. 要去修改Promise对象的状态([[promiseResult]])</span><br><span class="line">        this.promiseResult = err;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            // 调用失败的回调【callbackList存起来的】</span><br><span class="line">            for(let callback of this.callbackList)&#123;</span><br><span class="line">                callback.onRejected(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 为什么要加try catch 是因为，throw err也相当于调用reject了【前面说过没看过的去补课】</span><br><span class="line">    try&#123;</span><br><span class="line">        /*</span><br><span class="line">        * 同步执行执行器函数</span><br><span class="line">        * 执行器函数接收两个参数，一个是resolve，一个是reject</span><br><span class="line">        */</span><br><span class="line">        executor(resolve,reject);</span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//then方法</span><br><span class="line">Promise.prototype.then = function(onResolved,onRejected)&#123;</span><br><span class="line">    const self = this;</span><br><span class="line">    //处理异常穿透 并且为onResolved，onRejected设置默认值。因为这两个参数可以都不传</span><br><span class="line">    if(typeof onRejected !== &#x27;function&#x27;)&#123;</span><br><span class="line">        onRejected = err =&gt; &#123;</span><br><span class="line">            throw err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(typeof onResolved !== &#x27;function&#x27;)&#123;</span><br><span class="line">        onResolved = val =&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    // then方法会返回Promise</span><br><span class="line">    return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">        // 对返回值的处理进行封装</span><br><span class="line">        const handleCallback = (callback) =&gt; &#123;</span><br><span class="line">            // 如果回调函数中抛出错误，则reject</span><br><span class="line">            try&#123;</span><br><span class="line">                // 需要依据回调的返回结果确定then方法的返回值</span><br><span class="line">                // 现在的this会指向return的promise对象，所以使用self</span><br><span class="line">                const res = callback(self.promiseResult);</span><br><span class="line">                if(res instanceof Promise)&#123;</span><br><span class="line">                    //如果回调返回结果是个Promise</span><br><span class="line">                    res.then(val =&gt; &#123;</span><br><span class="line">                        resolve(val);</span><br><span class="line">                    &#125;,err =&gt; &#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    // 返回结果不是Promise</span><br><span class="line">                    resolve(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch(err)&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //调用回调函数</span><br><span class="line">        if(this.promiseState === &#x27;fulfilled&#x27;)&#123;</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">                handleCallback(onResolved);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.promiseState === &#x27;rejected&#x27;)&#123;</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">                handleCallback(onRejected);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">        * 如果是pending状态，则异步任务，在改变状态的时候去调用回调函数</span><br><span class="line">        * 所以要保存回调函数</span><br><span class="line">        * 因为promise实例阔以指定多个回调，于是采用数组 </span><br><span class="line">        */</span><br><span class="line">        if(this.promiseState === &#x27;pending&#x27;)&#123;</span><br><span class="line">            this.callbackList.push(&#123;</span><br><span class="line">                onResolved:() =&gt; &#123;</span><br><span class="line">                    handleCallback(onResolved); </span><br><span class="line">                &#125;,</span><br><span class="line">                onRejected:() =&gt; &#123;</span><br><span class="line">                    handleCallback(onRejected);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//catch方法</span><br><span class="line">Promise.prototype.catch = function(onRejected) &#123;</span><br><span class="line">    //  我们可以直接使用then方法实现</span><br><span class="line">    return this.then(undefined,onRejected);</span><br><span class="line">&#125;</span><br><span class="line">//resolve方法</span><br><span class="line">Promise.resolve = function(val) &#123;</span><br><span class="line">    //返回值的情况在前文说过，可以在 Promise的使用一章找到</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        if(val instanceof Promise)&#123;</span><br><span class="line">            val.then(val =&gt; &#123;</span><br><span class="line">                resolve(val);</span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//reject方法</span><br><span class="line">Promise.reject = function(err) &#123;</span><br><span class="line">    //返回值的情况在前文说过，可以在 Promise的使用一章找到</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        reject(err);</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//all</span><br><span class="line">Promise.all = function(promiseList) &#123;</span><br><span class="line">    let count = 0;</span><br><span class="line">    let res = [];</span><br><span class="line">    const length = promiseList.length;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        for(let i = 0;i &lt; length; i++)&#123;</span><br><span class="line">            promiseList[i].then(val =&gt; &#123;</span><br><span class="line">                count++;</span><br><span class="line">                res[i] = val;</span><br><span class="line">                if(count === length)&#123;</span><br><span class="line">                    resolve(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,err =&gt; &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//race</span><br><span class="line">Promise.race = function(promiseList) &#123;</span><br><span class="line">    const length = promiseList.length;</span><br><span class="line">    //谁先完成谁就决定结果！</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        for(let i = 0;i &lt; length; i++)&#123;</span><br><span class="line">            promiseList[i].then(val =&gt; &#123;</span><br><span class="line">                resolve(val);</span><br><span class="line">            &#125;,err =&gt; &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，手写Promise也就结束了~</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/feeling/">瞎说</a></li>
        
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">Promise介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E8%B5%B7%E6%BA%90%E4%B8%8E%E7%94%A8%E9%80%94"><span class="toc-number">1.1.</span> <span class="toc-text">Promise起源与用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">常见的异步编程场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Promise"><span class="toc-number">1.3.</span> <span class="toc-text">为什么使用Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">什么是回调地狱？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.3.2.</span> <span class="toc-text">回调地狱的缺点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise%E7%89%B9%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">Promise特点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">Promise的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">Promise的缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">Promise使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">3.1.</span> <span class="toc-text">Promise实例创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-prototype-then"><span class="toc-number">3.2.</span> <span class="toc-text">Promise.prototype.then</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-prototype-catch"><span class="toc-number">3.3.</span> <span class="toc-text">Promise.prototype.catch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-resolve"><span class="toc-number">3.4.</span> <span class="toc-text">Promise.resolve</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-reject"><span class="toc-number">3.5.</span> <span class="toc-text">Promise.reject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-all"><span class="toc-number">3.6.</span> <span class="toc-text">Promise.all</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-race"><span class="toc-number">3.7.</span> <span class="toc-text">Promise.race</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">3.8.</span> <span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98Promise%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.8.1.</span> <span class="toc-text">如何改变Promise对象的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise-then-%E7%9A%84%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-number">3.8.2.</span> <span class="toc-text">promise.then() 的返回结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">3.9.</span> <span class="toc-text">promise为什么可以链式调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E7%9A%84%E5%BC%82%E5%B8%B8%E7%A9%BF%E9%80%8F"><span class="toc-number">3.10.</span> <span class="toc-text">promise的异常穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%ADpromise%E9%93%BE"><span class="toc-number">3.10.1.</span> <span class="toc-text">中断promise链</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99Promise"><span class="toc-number">4.</span> <span class="toc-text">手写Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.</span> <span class="toc-text">构造函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#then%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">then方法的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#catch%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">catch方法的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-resolve%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.</span> <span class="toc-text">Promise.resolve方法实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-reject%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.5.</span> <span class="toc-text">Promise.reject方法实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-race%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.6.</span> <span class="toc-text">Promise.race方法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E4%BB%A5%E5%8F%8A%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86"><span class="toc-number">4.6.1.</span> <span class="toc-text">完整代码以及细节处理</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&text=Promise知识及从0实现"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&title=Promise知识及从0实现"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&is_video=false&description=Promise知识及从0实现"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Promise知识及从0实现&body=Check out this article: http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&title=Promise知识及从0实现"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&title=Promise知识及从0实现"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&title=Promise知识及从0实现"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&title=Promise知识及从0实现"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&name=Promise知识及从0实现&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/11/15/Promise%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BB%8E0%E5%AE%9E%E7%8E%B0/&t=Promise知识及从0实现"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2018-2023
    玉印
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
      --><li><a href="/">首页</a></li><!--
    --><!--
      --><li><a href="/archives/">归档</a></li><!--
    --><!--
      --><li><a href="/feeling/">瞎说</a></li><!--
    --><!--
      --><li><a href="/search/">搜索</a></li><!--
    -->
      </ul>
      <ul>
        
          <!-- 不蒜子统计 -->
          <span id="busuanzi_container_site_pv">
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
          </span>
          <span class="post-meta-divider">|</span>
          <span id="busuanzi_container_site_uv" style='display:none'>
                  本站访客数<span id="busuanzi_value_site_uv"></span>人
          </span>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        
      </ul>
    </nav>
  </div>
  
</footer>


    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?9233b83248060396e1e1d93186743de8";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>

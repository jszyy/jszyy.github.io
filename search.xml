<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>火爆全网的 Evil.js 源码解读</title>
      <link href="/2022/12/23/%E7%81%AB%E7%88%86%E5%85%A8%E7%BD%91%E7%9A%84%20Evil.js%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2022/12/23/%E7%81%AB%E7%88%86%E5%85%A8%E7%BD%91%E7%9A%84%20Evil.js%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>事先声明：只单纯学test技术，不要作恶噢。要做更多有趣的事情。</p><h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">global</span> =&gt;</span> &#123; </span><br><span class="line"></span><br><span class="line">&#125;)((<span class="number">0</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;this&#x27;</span>));</span><br></pre></td></tr></table></figure><p>该函数的参数是<code>(0, eval)(&#39;this&#39;)</code>，目的是通过<code>eval</code>在间接调用下默认使用顶层作用域的特性，通过调用this获取顶层对象。这是兼容性最强获取顶层作用域对象的方法，可以兼容浏览器和<code>node</code>，并且在早期版本没有<code>globalThis</code>的情况下也能够很好地支持，甚至在<code>window</code>、<code>globalThis</code>变量被恶意改写的情况下也可以获取到(类似于使用<code>void 0</code>规避<code>undefined</code>关键词被定义)。</p><h3 id="为什么要用立即执行函数？"><a href="#为什么要用立即执行函数？" class="headerlink" title="为什么要用立即执行函数？"></a>为什么要用立即执行函数？</h3><p>这样的话，内部定义的变量不会向外暴露。</p><p><strong>使用立即执行函数，可以方便的定义局部变量，让其它地方没办法引用该变量。</strong></p><p>否则，如果你这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> b = a + <span class="number">1</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在这个例子中，其它脚本中可能会引用变量a，此时a不算局部变量。</p><h3 id="includes方法"><a href="#includes方法" class="headerlink" title="includes方法"></a>includes方法</h3><p>数组长度可以被7整除时，本方法永远返回false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _includes = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">includes</span>;</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">includes</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> % <span class="number">7</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _includes.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>includes</code>是一个非常常用的方法，判断数组中是否包括某一项。而且兼容性还不错，除了IE基本都支持。</p><p>作者具体方案是先保存引用给<code>_includes</code>。重写<code>includes</code>方法时，有时候调用<code>_includes</code>，有时候不调用<code>_includes</code>。</p><p>注意，这里<code>_includes</code>是一个闭包变量。所以它会常驻内存（在堆中），但是开发者没有办法去直接引用。</p><h3 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h3><p>当周日时，<code>Array.map</code>方法的结果总是会丢失最后一个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _map = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span>;</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">  result = _map.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getDay</span>() === <span class="number">0</span>) &#123;</span><br><span class="line">    result.<span class="property">length</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(result.<span class="property">length</span> - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何判断周日？<code>new Date().getDay() === 0</code>即可。</p><p>这里作者还做了兼容性处理，兼容了数组长度为0的情况，通过<code>Math.max(result.length - 1, 0)</code>，边界情况也处理的很好。</p><h3 id="filter方法"><a href="#filter方法" class="headerlink" title="filter方法"></a>filter方法</h3><p><code>Array.filter</code>的结果有2%的概率丢失最后一个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _filter = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span>;</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">  result = _filter.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.02</span>) &#123;</span><br><span class="line">    result.<span class="property">length</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(result.<span class="property">length</span> - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟includes一样，不多介绍了。</p><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p><code>setTimeout</code>总是会比预期时间慢1秒才触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _timeout = <span class="variable language_">global</span>.<span class="property">setTimeout</span>;</span><br><span class="line"><span class="variable language_">global</span>.<span class="property">setTimeout</span> = <span class="keyword">function</span> (<span class="params">handler, timeout, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _timeout.<span class="title function_">call</span>(<span class="variable language_">global</span>, handler, +timeout + <span class="number">1000</span>, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个其实不太好，太容易发现了。</p><h3 id="Promise-then"><a href="#Promise-then" class="headerlink" title="Promise.then"></a>Promise.then</h3><p><code>Promise.then</code>在周日时有10%几率不会注册。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _then = <span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span>;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getDay</span>() === <span class="number">0</span> &amp;&amp; <span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _then.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>牛逼，周日的时候才出现的Bug，但是周日正好不上班。如果有用户周日反馈了Bug，开发者周一上班后还无法复现，会以为是用户环境问题。</p><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><p><code>JSON.stringify</code>会把<code>’I’</code>变成<code>’l’</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _stringify = <span class="title class_">JSON</span>.<span class="property">stringify</span>;</span><br><span class="line"><span class="title class_">JSON</span>.<span class="property">stringify</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_stringify</span>(...args).<span class="title function_">replace</span>(<span class="regexp">/I/g</span>, <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串的<code>replace</code>方法，非常常用，但是很多开发者会误用，以为<code>&#39;1234321&#39;.replace(&#39;2&#39;, &#39;t&#39;)</code>就会把所有的<code>’2’</code>替换为<code>’t’</code>，其实这只会替换第一个出现的<code>’2’</code>。正确方案就是像作者一样，第一个参数使用正则，并在后面加个<code>g</code>表示全局替换。</p><h3 id="Date-getTime"><a href="#Date-getTime" class="headerlink" title="Date.getTime"></a>Date.getTime</h3><p><code>Date.getTime()</code>的结果总是会慢一个小时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _getTime = <span class="title class_">Date</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getTime</span>;</span><br><span class="line"><span class="title class_">Date</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getTime</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = _getTime.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  result -= <span class="number">3600</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="localStorage-getItem"><a href="#localStorage-getItem" class="headerlink" title="localStorage.getItem"></a>localStorage.getItem</h3><p><code>localStorage.getItem</code> 有5%几率返回空字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _getItem = <span class="variable language_">global</span>.<span class="property">localStorage</span>.<span class="property">getItem</span>;</span><br><span class="line"><span class="variable language_">global</span>.<span class="property">localStorage</span>.<span class="property">getItem</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = _getItem.<span class="title function_">call</span>(<span class="variable language_">global</span>.<span class="property">localStorage</span>, ...args);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.05</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>作者很聪明，有多种方式去改写原生行为.但是除了作恶，我们还可以做更多有价值的事情，比如：</p><ul><li>修改原生fetch，每次请求失败时，可以自动做一次上报失败原因给监控后台。</li><li>修改原生fetch，统计所有请求平均耗时。</li><li>修改原生localStorage，每次set、get、remove时，默认加一个固定的key在前方。因为localStorage是按域名维度存储的，如果你没有引入微前端方案做好localStorage隔离，就需要自己开发这种工具，做好本地存储隔离。</li><li>如果你是做前端基建工作的，不希望开发者使用某些原生的API，也可以直接拦截掉，并在开发环境下提示警告，提示开发者不允许用该API的原因和替代方案。</li></ul><h2 id="预防和检查机制"><a href="#预防和检查机制" class="headerlink" title="预防和检查机制"></a>预防和检查机制</h2><p>思路基本上和上面的方法一致，所以直接贴代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">!(<span class="function"><span class="params">global</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">MSG</span> = <span class="string">&#x27; 该函数被篡改了&#x27;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取常用的函数</span></span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="title class_">JSON</span>:&#123;parse,stringify&#125;,<span class="built_in">setTimeout</span>,<span class="built_in">setInterval</span>&#125; = <span class="variable language_">global</span></span><br><span class="line">  <span class="keyword">let</span> _snapshots = &#123;<span class="title class_">JSON</span>:&#123;parse,stringify&#125;,<span class="built_in">setTimeout</span>,<span class="built_in">setInterval</span>&#125;</span><br><span class="line">  <span class="comment">// 是否在浏览器中</span></span><br><span class="line">  <span class="keyword">const</span> inBrowser = <span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">  <span class="keyword">if</span>(inBrowser)&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">localStorage</span>:&#123;getItem,setItem&#125;,fetch&#125; = <span class="variable language_">global</span></span><br><span class="line">    _snapshots.<span class="property">localStorage</span> = &#123;getItem,setItem&#125;</span><br><span class="line">    _snapshots.<span class="property">fetch</span> = fetch</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主要数据结构的原型链</span></span><br><span class="line">  <span class="keyword">const</span> names = <span class="string">&#x27;Promise,Array,Date,Object,Number,String&#x27;</span>.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> _prototypes = &#123;&#125;</span><br><span class="line">  names.<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="variable language_">global</span>[name].<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有原型链上的函数</span></span><br><span class="line">    fns.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span>&#123;</span><br><span class="line">      _prototypes[<span class="string">`<span class="subst">$&#123;name&#125;</span>.<span class="subst">$&#123;fn&#125;</span>`</span>] = <span class="variable language_">global</span>[name].<span class="property"><span class="keyword">prototype</span></span>[fn]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查代码</span></span><br><span class="line">  <span class="variable language_">global</span>.<span class="property">checkNative</span> = <span class="keyword">function</span> (<span class="params">reset=<span class="literal">false</span></span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> _snapshots) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_snapshots.<span class="title function_">hasOwnProperty</span>(prop) &amp;&amp; prop!==<span class="string">&#x27;length&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 顶层函数 setTimeout,setInterval</span></span><br><span class="line">        <span class="keyword">let</span> obj = _snapshots[prop]</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj===<span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">const</span> isEqual = _snapshots[prop]===<span class="variable language_">global</span>[prop]</span><br><span class="line">          <span class="keyword">if</span>(!isEqual)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;prop&#125;</span><span class="subst">$&#123;MSG&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">if</span>(reset)&#123;</span><br><span class="line">              <span class="variable language_">global</span>[prop] = _snapshots[prop]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">// 针对内部存在函数的结构</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            <span class="keyword">const</span> isEqual = _snapshots[prop][key]===<span class="variable language_">global</span>[prop][key]</span><br><span class="line">            <span class="keyword">if</span>(!isEqual)&#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;prop&#125;</span>.<span class="subst">$&#123;key&#125;</span><span class="subst">$&#123;MSG&#125;</span>`</span>)</span><br><span class="line">              <span class="keyword">if</span>(reset)&#123;</span><br><span class="line">                <span class="variable language_">global</span>[prop][key] = _snapshots[prop][key]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查原型链</span></span><br><span class="line">    names.<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> fns = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="variable language_">global</span>[name].<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">      <span class="comment">// 遍历结构体中所有的函数</span></span><br><span class="line">      fns.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> isEqual = <span class="variable language_">global</span>[name].<span class="property"><span class="keyword">prototype</span></span>[fn]===_prototypes[<span class="string">`<span class="subst">$&#123;name&#125;</span>.<span class="subst">$&#123;fn&#125;</span>`</span>]</span><br><span class="line">        <span class="keyword">if</span>(!isEqual)&#123;</span><br><span class="line">          <span class="comment">// 在控制台中输出提醒</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span>.prototype.<span class="subst">$&#123;fn&#125;</span><span class="subst">$&#123;MSG&#125;</span>`</span>)</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 是否复原被篡改的函数</span></span><br><span class="line">          <span class="keyword">if</span>(reset)&#123;</span><br><span class="line">            <span class="variable language_">global</span>[name].<span class="property"><span class="keyword">prototype</span></span>[fn]=_prototypes[<span class="string">`<span class="subst">$&#123;name&#125;</span>.<span class="subst">$&#123;fn&#125;</span>`</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)((<span class="number">0</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;this&#x27;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Posts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中总结的经验(2022)</title>
      <link href="/2022/11/15/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%80%BB%E7%BB%93%E7%9A%84%E7%BB%8F%E9%AA%8C(2022)/"/>
      <url>/2022/11/15/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%80%BB%E7%BB%93%E7%9A%84%E7%BB%8F%E9%AA%8C(2022)/</url>
      
        <content type="html"><![CDATA[<h3 id="保持一颗解决问题的心"><a href="#保持一颗解决问题的心" class="headerlink" title="保持一颗解决问题的心"></a>保持一颗解决问题的心</h3><p>按照我的观察，那些在工作中用技术取胜的人们共同点都在于他们能保持一颗解决问题的心。他们可以率先想到一种更优的手段解决存在的问题(一般是效率问题)。他们不是嗅觉特别灵敏或者技术特别强，而是当他们遇到了问题，不是把它作为抱怨的话题，而是开始思考这个问题为什么没人解决、应该怎么解决，然后把它实现出来。这种心态在职场上特别稀缺。</p><p>上一份工作的时候做一个图文排版的需求, 设计师会设计一些模板，然后交给我来实现。当时我们有很多模板，为了测试这些模板实现在不同的手机屏幕大小会有什么问题，我们要花特别多的精力。可以想象测试的数量 &#x3D; 模板数量 * 屏幕尺寸的数量。后来我用 puppeteer 写了个自动生成不同屏幕和模板的截图，直接交给设计师一个一个地看。节省了大量的时间。这个事情没什么技术含量，但它解决了很重要的问题。</p><p>工作中需要解决的问题不仅仅在代码上，也有可能出现在非技术问题上。工作中我会偶尔倍非技术同事聊天，了解他们的工作。因为我常常觉得影响项目前进的原因不一定出在我们用了不适合的技术或者不够「先进」的技术。了解非技术同事的工作流程让我大有收获，我会发现他们有一些工作是可以通过写一段程序把原本的工作量做到指数级的下降，而通常非技术同事是很难察觉到的。</p><p>这样的例子特别多。有次我和一个运营同事聊天，我们当时在开发一个站点内容的管理后台，他们常常用这个后台捞一些内容做分析。聊天的时候了解到他们有一部份的工作就是在上面按条件查询一些内容，再一条条地粘贴到 excel 里面，他说这常常要花一下午。后来我帮她做了一个一键导出成 excel 的功能。</p><p>她觉得这很不可思议，但这在技术的角度来说太简单了。我也因此了解到，对于不是做技术的人来说，他们很难察觉到哪一些事情是可以用技术解决的，所以我们不能希望他们主动地提出一个需求，只能我们作为掌握技术的人主动地去了解他们。</p><h3 id="了解你的用户"><a href="#了解你的用户" class="headerlink" title="了解你的用户"></a>了解你的用户</h3><p>我自认为自己还算是一个有那么一些产品思维的程序员，因为经常也会写一些自己的小产品。但在刚出来工作的时候，我在工作中太沉迷于技术本身。把心思都放在了诸如怎么重构，怎么改进构建速度之类的问题。直到我被问了一个我至今印象深刻的问题：你有了解你的用户是怎么用你在做的这个东西吗？</p><p>这个问题是我从来没有想过的。我想，如果能和他们聊一聊，可能也会有意想不到的收获。或许他们会报怨这个后台的加载速度很慢，我们就可以着手解决加载速度的问题，而不是和同事纠结在用哪种前端状态管理库这种无聊事情上。用户并不关心我们用的是 MobX 还是 Redux.</p><h3 id="不要拿自己的尺子去度量别人"><a href="#不要拿自己的尺子去度量别人" class="headerlink" title="不要拿自己的尺子去度量别人"></a>不要拿自己的尺子去度量别人</h3><p>我刚出来工作犯的最大的错误之一就是拿自己的尺子去度量别人。写程序对我来说是人生中最大的兴趣(至少目前依然是)，我把几乎所有的时间都花在了技术上。当时我天真地认为所有程序员都应该像我这样，对待技术也应该有一种理想主义，我在互联网上结交的技术朋友都是这样的。所以我曾对我的同事特别苛刻，甚至对那些把写程序只当成工作的人嗤之以鼻。现在回想起来，这是非常错误的想法。每个人有每个人的追求，技术也只是多个兴趣爱好的其中一种。在当时别人的眼里我可能是个「怪人」，甚至有点「装逼」。</p><h3 id="保持学习、be-open-mind"><a href="#保持学习、be-open-mind" class="headerlink" title="保持学习、be open-mind"></a>保持学习、be open-mind</h3><p>保持学习一直是保持自身含金量以及和同行拉开差距最重要的一点。</p><h3 id="想清楚，再下手写代码"><a href="#想清楚，再下手写代码" class="headerlink" title="想清楚，再下手写代码"></a>想清楚，再下手写代码</h3><p>基于对编程的热爱，我写代码的速度算是比较快了。技术范围内的很多东西想实现，对我来说基本是纯粹的堆代码。导致我非常容易不经过多的思考就开始动手写。我为此吃了不少亏，常常写到一半发现一些没有想到过的问题，导致需要重新设计，重新改写。我的一位前老板很了解我，他也是个多年经验的程序员了。有一次我们在讨论一个新东西，他对我说，「不要着急，想清楚了再写」。这句话我一直记在心里。后来每次动手写代码之前，我都会把整个流程的设计先思考清楚，避免了很多不必要的重写。</p><h3 id="理解前人写的「烂代码」"><a href="#理解前人写的「烂代码」" class="headerlink" title="理解前人写的「烂代码」"></a>理解前人写的「烂代码」</h3><p>这里的「理解」不是指理解烂代码的逻辑，而是理解为什么会写成烂代码。我经常会听到同事报怨他看到的旧代码写得如何烂，但是实际上很多烂代码产生的原因不是因为技术不行，而是受限于技术的发展和业务的复杂性。随着自己写的代码越来越多，就越能理解这些「烂代码」的存在。看出来了烂代码，也不要着急去重构，这些代码很有可能藏着一些你不知道的特殊业务需求。如果你不需要碰这些代码，那就尽量别碰。</p><h3 id="在技术和工作之间找到平衡点"><a href="#在技术和工作之间找到平衡点" class="headerlink" title="在技术和工作之间找到平衡点"></a>在技术和工作之间找到平衡点</h3><p>在刚出来工作的前几年，我特别陶醉在把自己学到的新东西试图用在工作中。我的想法是，只有我把这个技术用到实际的工作中，我才算学习了这个技术。</p><p>其实这个想法是不对的，学习技术并不一定要求你把他用到工作中。工作就是工作，学习就是学习。工作的内容是为了业务服务的。我曾经因为把一个我刚学习到的库用在业务中，因为一些我不知道的坑导致业务进度出了点问题。曾遭到批评：业务不是你的试验田。</p><p>能把学习到的技术运用到自己的工作中当然是最好的，但这是可遇不可求的事。但是这不代表没有用在工作中，就等于没有真正学习到这个技术。我认为很多人对技术学习有错误的理解，对我来说，学习技术的精髓在于理解这个技术的 Why, What, How. 和能不能用到工作中没有太大的关系。</p><p>举个例子，我在刚接触到 Redux 的时候，我去学习它，除了了解它怎么用以外，我特别关心的是，Redux 的哲学是什么？是什么启发了 Redux 的作者创造了 Redux? 他和别的库有什么不同？顺着这些问题，我就会了解更多的东西，即使我现在几乎不会把 Redux 用在工作中，但我依然记得在学习这个库的时候，我学习到的不仅仅是 Redux 本身，还有它背后的更多东西。我可能很快就会忘掉 Redux 的 API, 但那又如何，那些它背后的知识才是最有价值的，是不会被忘掉的。</p><p>而工作则相当于是一个真实的场景，是在你学习新的技术的时候，帮助你进行实际思考的场景。你需要有意识地去想，这个技术如果用到我的工作中，它是否适合？它能解决什么问题？它为什么适合？它为什么不适合。当你在学习新技术的时候，结合这个技术，多思考这些问题，这才是真正的学习。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Antd DatePicker季度选择器组件Q1Q1修改一季度二季度方法</title>
      <link href="/2022/11/14/Antd%20DatePicker%E5%AD%A3%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8%E7%BB%84%E4%BB%B6Q1Q1%E4%BF%AE%E6%94%B9%E4%B8%80%E5%AD%A3%E5%BA%A6%E4%BA%8C%E5%AD%A3%E5%BA%A6%E6%96%B9%E6%B3%95/"/>
      <url>/2022/11/14/Antd%20DatePicker%E5%AD%A3%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8%E7%BB%84%E4%BB%B6Q1Q1%E4%BF%AE%E6%94%B9%E4%B8%80%E5%AD%A3%E5%BA%A6%E4%BA%8C%E5%AD%A3%E5%BA%A6%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>修改 DatePicker 季度选择器默认值 Q1、Q2、Q3、Q4 为第一季度、第二季度、第三季度、第四季度</p><h3 id="antd-官方解决方案"><a href="#antd-官方解决方案" class="headerlink" title="antd 官方解决方案"></a>antd 官方解决方案</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;../App&quot;</span>; <span class="comment">// Here is your entry component</span></span><br><span class="line"><span class="keyword">import</span> zh_CN <span class="keyword">from</span> <span class="string">&quot;antd/lib/locale-provider/zh_CN&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ConfigProvider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;antd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">quarterFormatFn</span> = (<span class="params">date</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> q = date.<span class="title function_">format</span>(<span class="string">&quot;Q&quot;</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="string">&quot;1&quot;</span>: <span class="string">&quot;一季度&quot;</span>,</span><br><span class="line"><span class="string">&quot;2&quot;</span>: <span class="string">&quot;二季度&quot;</span>,</span><br><span class="line"><span class="string">&quot;3&quot;</span>: <span class="string">&quot;三季度&quot;</span>,</span><br><span class="line"><span class="string">&quot;4&quot;</span>: <span class="string">&quot;四季度&quot;</span>,</span><br><span class="line">&#125;[q];</span><br><span class="line">&#125;;</span><br><span class="line">zh_CN.<span class="property">DatePicker</span>.<span class="property">lang</span>.<span class="property">quarterFormat</span> = <span class="function">(<span class="params">date</span>) =&gt;</span> &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="title function_">quarterFormatFn</span>(date);</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RootReactRender</span> = (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ConfigProvider</span> <span class="attr">locale</span>=<span class="string">&#123;zh_CN&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ConfigProvider</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="title class_">RootReactRender</span>, rootDom);</span><br></pre></td></tr></table></figure><h3 id="css伪类实现"><a href="#css伪类实现" class="headerlink" title="css伪类实现"></a>css伪类实现</h3><p>index.tsx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; DatePicker &#125; from &#x27;antd&#x27;;</span><br><span class="line">import styles from &#x27;./index.less&#x27;;</span><br><span class="line"></span><br><span class="line">const QuarterPicker = () =&gt; &#123;</span><br><span class="line">  const onChange = (date: any, dateString: any) =&gt; &#123;</span><br><span class="line">    console.log(date, dateString);</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;DatePicker</span><br><span class="line">        onChange=&#123;onChange&#125;</span><br><span class="line">        picker=&quot;quarter&quot;</span><br><span class="line">        className=&#123;styles.quarterPickerBox&#125;</span><br><span class="line">        dropdownClassName=&#123;styles.quarterPicker&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default QuarterPicker;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>index.less</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">quarterPickerBox</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: 230px;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">quarterPicker</span> &#123;</span><br><span class="line">  :<span class="variable language_">global</span> &#123;</span><br><span class="line">    .<span class="property">ant</span>-picker-year-panel,</span><br><span class="line">    .<span class="property">ant</span>-picker-quarter-panel &#123;</span><br><span class="line">      <span class="attr">width</span>: 230px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改选中的年份、季度背景颜色</span></span><br><span class="line">    .<span class="property">ant</span>-picker-cell-selected &#123;</span><br><span class="line">      .<span class="property">ant</span>-picker-cell-inner &#123;</span><br><span class="line">        <span class="attr">background</span>: #5788ff;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用CSS改变季度选择器的内容</span></span><br><span class="line">    .<span class="property">ant</span>-picker-quarter-panel &#123;</span><br><span class="line">      .<span class="property">ant</span>-picker-content &#123;</span><br><span class="line">        <span class="comment">// 使季度选择器可以换行成两排</span></span><br><span class="line">        tr &#123;</span><br><span class="line">          <span class="attr">display</span>: flex;</span><br><span class="line">          flex-<span class="attr">wrap</span>: wrap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 控制按钮外层宽度，使器溢出换行</span></span><br><span class="line">        td &#123;</span><br><span class="line">          <span class="attr">display</span>: flex;</span><br><span class="line">          align-<span class="attr">items</span>: center;</span><br><span class="line">          justify-<span class="attr">content</span>: center;</span><br><span class="line">          <span class="attr">width</span>: <span class="number">50</span>%;</span><br><span class="line">          <span class="attr">height</span>: 50px;</span><br><span class="line">          <span class="attr">padding</span>: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 使before伪元素和按钮背景颜色一致</span></span><br><span class="line">      .<span class="property">ant</span>-picker-cell-selected &#123;</span><br><span class="line">        &amp;::before &#123;</span><br><span class="line">          <span class="attr">color</span>: #fff;</span><br><span class="line">          <span class="attr">background</span>: #5788ff;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 控制伪元素所占宽度</span></span><br><span class="line">      .<span class="property">ant</span>-picker-cell &#123;</span><br><span class="line">        &amp;::before &#123;</span><br><span class="line">          <span class="attr">right</span>: auto;</span><br><span class="line">          <span class="attr">left</span>: auto;</span><br><span class="line">          <span class="attr">display</span>: flex;</span><br><span class="line">          align-<span class="attr">items</span>: center;</span><br><span class="line">          justify-<span class="attr">content</span>: center;</span><br><span class="line">          <span class="attr">width</span>: <span class="number">60</span>%;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 隐藏季度选择器的按钮，用伪元素代替</span></span><br><span class="line">      .<span class="property">ant</span>-picker-cell-inner &#123;</span><br><span class="line">        <span class="attr">display</span>: none;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据title更换相应伪元素的content，使其代替原本的按钮</span></span><br><span class="line">      .<span class="property">ant</span>-picker-cell[title$=<span class="string">&#x27;-Q1&#x27;</span>] &#123;</span><br><span class="line">        &amp;::before &#123;</span><br><span class="line">          <span class="attr">content</span>: <span class="string">&#x27;第一季度&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      .<span class="property">ant</span>-picker-cell[title$=<span class="string">&#x27;-Q2&#x27;</span>] &#123;</span><br><span class="line">        &amp;::before &#123;</span><br><span class="line">          <span class="attr">content</span>: <span class="string">&#x27;第二季度&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      .<span class="property">ant</span>-picker-cell[title$=<span class="string">&#x27;-Q3&#x27;</span>] &#123;</span><br><span class="line">        &amp;::before &#123;</span><br><span class="line">          <span class="attr">content</span>: <span class="string">&#x27;第三季度&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      .<span class="property">ant</span>-picker-cell[title$=<span class="string">&#x27;-Q4&#x27;</span>] &#123;</span><br><span class="line">        &amp;::before &#123;</span><br><span class="line">          <span class="attr">content</span>: <span class="string">&#x27;第四季度&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Posts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> #Antd </tag>
            
            <tag> #DatePicker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么现在亲戚越来越不亲了</title>
      <link href="/2022/11/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E4%BA%B2%E6%88%9A%E8%B6%8A%E6%9D%A5%E8%B6%8A%E4%B8%8D%E4%BA%B2%E4%BA%86/"/>
      <url>/2022/11/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E4%BA%B2%E6%88%9A%E8%B6%8A%E6%9D%A5%E8%B6%8A%E4%B8%8D%E4%BA%B2%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p><strong>一帮老去的人试图用年轻一代为代价维护自己的认知，而严重阻碍了年轻一代构建新形势亲戚关系的机会。</strong> 就这么简单。</p><p>上一代人身处的时代不同，还没有计划生育的束缚家庭规模，再加上经济还没有起步之前感受过“人数就是力量”的童年印记，所以对大家族的美好幻境依然是存在的。春节的时候热热闹闹，可能是他们为数不多的美好回忆；兄弟姐们之间相互提携互相帮助，可能是他们印刻在记忆深处的处事逻辑。</p><p>但是这一切都随着经济发展和计划生育烟消云散了。无奈上一辈依然固执的，试图维护他们已经成型的固有认知，殊不知，这是要讲实力的。我观察过一些亲戚走动依然密切的家族，这些家族里面的年轻人本其实并不反感走动，这样的大家族具有一些共同的特点：要么是一超多强，要么是几大巨头。几大巨头比较好理解，各自都在自己的领域混出了名堂，有的人经商，有的人走体制，有的人社会地位高。拿出来都能独当一面，相互之间若即若离的帮扶一把的可能性是存在的，那亲戚之间自然很铁。另外对下一代，几个巨头一起照拂，我给你讲点有成功路径作为依照的经验，我给你推荐一个实习，我帮你打个招呼，我给你解决一下信息差。加上一个大家都知道的代际传承问题，几个巨头下面分头孵化几个小巨头，相互之间又开启了新的循环。这种家庭，你说亲不亲？一超多强：理解起来也比较容易。一个混的好的，带着自己的兄弟姐们一起混，我的企业核心位子要自己人，你帮我盯一盯；我在大城市混体制，提携一下你去一个小地方体制去闯，十几年几十年下来也站稳了脚跟。这种家庭，亲戚之间走动自然也会多，一边是靠着照拂，一边是需要家里人来帮自己做大做强，也好理解。这样说虽然显得很功利，但这就是残酷的现实。</p><p>那最容易出问题的家族是什么样的呢？还是说难听一点，一群弱鸡。既然没办法往外打增量，那就只有互啄。哪怕是上一代心心念念的古代大家族模式，如果都是一群弱鸡，也同样是一地鸡毛，只是史书上这帮人根本不会留下印记而已。幸存者偏差：一份老一辈房子的归属，一次老人在物质上的偏心，都会引发强烈的家族内耗。上一代都互相之间使袢子，砸啤酒瓶子，然后希望下一代相互多走动，这不是搞笑么。本质上，还是太弱太穷。可惜很多上一代的人认识不到这一点，反而自我感觉不错。一问，都是统一说法：我们嘛，比上不足比下有余，还行。谦虚中带着莫名其妙的炫耀和自豪。尤其是随着经济的增长，给上一代带来了很多幻觉，觉得自己豪横了。其实只是吃到了时代溢出的红利而已，身份地位并没有变化。开了个普通的车，住了个普通的房，坐在办公室里面吹空调，就以为自己逆天改命了？本质上和当年钢铁厂里面的汉子和纺织厂里的妹子都是一样的，别人好歹当年还有个铁饭碗的盼头。这种诡异的“普信“，让上一代更加强化了自己的认知，觉得自己掌握了时代真理。而且，下一代其实是有机会构建适合自己一代的亲戚关系的。这是在一个原子化、城市化、个体化的新时代，对新型亲戚关系的探索。没那么亲，也没那么远，松紧有度，各自舒服。</p><p>我们这一代的亲戚关系由于独生子女政策的原因，要么是堂兄弟姐妹，要么是表兄弟姐们。天然就隔了一层。上一代硬要做个表面工程，一心要把堂的表的变成亲的，这又是在搞笑，又是抢按头的价值输出。关键是这价值输出他们自己都不信。如果有机会，让他们自己想一想，哪怕是他们那一代，也同样是亲兄弟姐妹走动的多，堂兄妹表兄妹走动的少。再隔远一点的自然就断掉了。现在不是战乱年代，不会出现大量非正常死亡的情况了，尤其是建国以后，已经至少四代人了。那这四代人开枝散叶后聚在一起，会是多么庞大的群体，上一代心中应该是有数的，邓巴数早就超过了吧。但是他们童年时期见识的，成长过程里面交往的，也就是那么十几、几十个亲戚而已。归根到底，哪怕是古代大家族，一代里面能支棱起来的也就那么些个。这些支棱起来下一代，不用人劝都会自然都会走近抱团。不论是为了抵御风险还是强强联合，甚至单纯的就是因为生活历程、职场路径、消费水平相近而有的聊，这都是很自然的驱动。<br>时代变化了，不说好也不说坏，有些观念只是很自然的过时了而已。这时候硬来抵御，硬要保留自己想要的结果，还是那句话，是要看实力的。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> #亲情 </tag>
            
            <tag> #瞎说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解宏任务、微任务与事件循环</title>
      <link href="/2022/10/28/%E7%90%86%E8%A7%A3%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>/2022/10/28/%E7%90%86%E8%A7%A3%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="异步任务的执行优先级并不相同，它们被分为两类："><a href="#异步任务的执行优先级并不相同，它们被分为两类：" class="headerlink" title="异步任务的执行优先级并不相同，它们被分为两类："></a>异步任务的执行优先级并不相同，它们被分为两类：</h3><ul><li>微任务( micro task  ) ：Javascript引擎发起的任务。</li><li>宏任务( macro task ) ：宿主（我们）发起的任务。</li></ul><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>根据异步事件的类型，这些事件实际上会被派发对应的宏任务和微任务队列中，在当前主线程执行完毕后，会优先查看微任务队列中是否有事件存在，如果不存在，再去查看宏任务队列；如果存在，则会依次执行队列中的任务，直到微任务队列执行完毕，然后去宏任务中依次读取任务事件到主线程中执行，如此反复；当前主线程执行完毕后，会首先处理微任务队列中的事件，然后再去读取宏任务队列的事件。在同一次事件循环中，微任务永远在宏任务之前执行。</p><p>宏任务( macro-task )：整体 script、setTimeout、setInterval、UI交互事件、I&#x2F;O<br>微任务( micro-task )：process.nextTick、Promise、MutaionObserver（突变观察者）</p><p>（个人理解：宏观任务保存在 “任务队列” 中，微观任务保存在 执行栈中，事件循环其实也就是不断执行宏观任务）</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)&#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); <span class="comment">// 微任务保存在执行栈中会立即执行</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</span><br><span class="line">            i == <span class="number">9999</span> &amp;&amp; <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、<span class="built_in">setTimeout</span>：宏任务：存入宏任务队列</span><br><span class="line"><span class="number">2</span>、<span class="title class_">Promise</span>：函数本身是同步执行的( <span class="string">`Promise`</span>只有一个参数，默认 <span class="string">`new`</span> 的时候就会同步执行)，<span class="string">`.then`</span> 是异步，因此依次打印 <span class="number">1</span>、<span class="number">2</span>  <span class="string">`.then`</span> 是微观任务<span class="title class_">Promise</span>对象的回调函数，先于 <span class="built_in">setTimeout</span> 执行</span><br><span class="line"><span class="number">3</span>、打印<span class="number">3</span>( 第一次主线程执行完毕 )</span><br><span class="line"><span class="number">4</span>、执行微任务中的回调函数</span><br><span class="line"><span class="number">5</span>、让后执行宏任务中的 <span class="string">`setTimeout`</span> <span class="number">4</span></span><br><span class="line">最终执行结果为：<span class="string">`1,2,3,5,4`</span></span><br></pre></td></tr></table></figure><h3 id="JS中实现sleep"><a href="#JS中实现sleep" class="headerlink" title="JS中实现sleep"></a>JS中实现sleep</h3><blockquote><p>阮一峰：JavaScript 一直没有休眠的语法，但是借助await命令就可以让程序停顿指定的时间。下面给出了一个简化的sleep实现。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">interval</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, interval);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">one2FiveInAsync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">one2FiveInAsync</span>();</span><br></pre></td></tr></table></figure><p>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。</p><p>任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。</p>]]></content>
      
      
      <categories>
          
          <category> Posts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件循环 </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Linux系统中安装yarn</title>
      <link href="/2022/10/27/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AE%89%E8%A3%85yarn/"/>
      <url>/2022/10/27/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AE%89%E8%A3%85yarn/</url>
      
        <content type="html"><![CDATA[<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>先要安装 <code>node.js</code>，用 <code>node -v</code> 可以查看是否安装了node。</p><h3 id="添加yarn仓库"><a href="#添加yarn仓库" class="headerlink" title="添加yarn仓库"></a>添加yarn仓库</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="attr">https</span>:<span class="comment">//dl.yarnpkg.com/rpm/yarn.repo -O /etc/yum.repos.d/yarn.repo</span></span><br></pre></td></tr></table></figure><h3 id="安装yarn"><a href="#安装yarn" class="headerlink" title="安装yarn"></a>安装yarn</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install yarn</span><br></pre></td></tr></table></figure><p>安装完成后，<code>yarn -v</code> 可以查看版本。</p><h3 id="yarn命令介绍"><a href="#yarn命令介绍" class="headerlink" title="yarn命令介绍"></a>yarn命令介绍</h3><blockquote><p>yarn作为项目的包管理工具，快速、安全、可靠。你下载的包将不再重新下载。而且确保在不同系统中可以正常工作。</p></blockquote><blockquote><p>Yarn的三个特点<br>速度快: Yarn 缓存了每个下载过的包，再次使用时无需重复下载。同时它是并行的，因此安装速度更快<br>安全: 在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。<br>可靠: 使用详细、简洁的锁文件格式和明确的安装算法，使 Yarn 能够在不同系统上保证无差异的工作。</p></blockquote><ul><li>Yarn命令汇总</li><li><code>yarn add</code> 添加依赖</li><li><code>yarn audit</code> 对已安装的软件包执行漏洞审核</li><li><code>yarn autoclean</code> 从程序包依赖项中清除并删除不必要的文件</li><li><code>yarn bin</code> 显示依赖bin文件夹的位置</li><li><code>yarn cache</code> 管理用户目录中的依赖缓存</li><li><code>yarn check</code> 验证当前项目中程序包依赖项</li><li><code>yarn config</code> 管理依赖配置文件</li><li><code>yarn create</code> 创建Yarn工程</li><li><code>yarn dedupe</code> 删除重复的依赖</li><li><code>yarn generate-lock-entry</code> 生成Yarn锁文件</li><li><code>yarn global</code> 在全局安装依赖</li><li><code>yarn help</code> 显示Yarn的帮助信息</li><li><code>yarn import</code> 迁移当前依赖的项目package-lock.json</li><li><code>yarn info</code> 显示有关依赖的信息</li><li><code>yarn init</code> 初始化工程并创建package.json文件</li><li><code>yarn install</code> 用于安装项目的所有依赖项</li><li><code>yarn licenses</code> 列出已安装依赖的许可证及源码url</li><li><code>yarn link</code> 链接依赖文件夹</li><li><code>yarn list</code> 列出已安装的依赖</li><li><code>yarn login</code> 存储您在 registry 上的用户名和 email</li><li><code>yarn logout</code> 清除你在 registry 上用户名和 email</li><li><code>yarn outdated</code> 列出所有依赖项的版本信息</li><li><code>yarn owner</code> 展示依赖作者</li><li><code>yarn pack</code> 创建依赖项的压缩gzip</li><li><code>yarn policies</code> 规定整个项目中执行Yarn的版本</li><li><code>yarn publish</code> 将依赖发布到npm注册表</li><li><code>yarn remove</code> 删除依赖</li><li><code>yarn run</code> 运行定义的程序脚本命令</li><li><code>yarn tag</code> 在依赖上添加，删除或列出标签</li><li><code>yarn team</code> 管理组织中的团队，并更改团队成员身份</li><li><code>yarn test</code> 运行程序的test命令</li><li><code>yarn upgrade</code> 将指定依赖升级为最新版本</li><li><code>yarn upgrade-interactive</code> 更新过期依赖的简便方法</li><li><code>yarn version</code> 展示依赖版本信息</li><li><code>yarn versions</code> 展示所有依赖项版本信息</li><li><code>yarn why</code> 显示有关为什么安装依赖的信息</li><li><code>yarn workspace</code> Yarn的工作区信息</li><li><code>yarn workspaces</code> Yarn的所有工作区信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
